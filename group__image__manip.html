<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OldSchool Library: Image manipulation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OldSchool Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__image__manip.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Image manipulation<div class="ingroups"><a class="el" href="group__drawing__adv.html">Advanced</a> &raquo; <a class="el" href="group__image.html">Images</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga592a8dd6b6ebd9fe88af80034a1883eb" id="r_ga592a8dd6b6ebd9fe88af80034a1883eb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga592a8dd6b6ebd9fe88af80034a1883eb">OSL_WRITE_FLAGS</a> { <a class="el" href="#gga592a8dd6b6ebd9fe88af80034a1883ebad97243719237d70adc2a619075d734a2">OSL_WRI_ALPHA</a> = 1
 }</td></tr>
<tr class="separator:ga592a8dd6b6ebd9fe88af80034a1883eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac87ef5c4f7054e7d7ce8c74dfeb65dfa" id="r_gac87ef5c4f7054e7d7ce8c74dfeb65dfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac87ef5c4f7054e7d7ce8c74dfeb65dfa">oslCreateImageTile</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, int offsetX0, int offsetY0, int offsetX1, int offsetY1)</td></tr>
<tr class="separator:gac87ef5c4f7054e7d7ce8c74dfeb65dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82753be3adf49fa4bed8aaa0b43dd97a" id="r_ga82753be3adf49fa4bed8aaa0b43dd97a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga82753be3adf49fa4bed8aaa0b43dd97a">oslCreateImageTileSize</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, int offsetX0, int offsetY0, int width, int height)</td></tr>
<tr class="separator:ga82753be3adf49fa4bed8aaa0b43dd97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d537c26aa5e5141b3bfe0f8e739153" id="r_ga45d537c26aa5e5141b3bfe0f8e739153"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga45d537c26aa5e5141b3bfe0f8e739153">oslConvertImageTo</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *imgOriginal, int newLocation, int newFormat)</td></tr>
<tr class="separator:ga45d537c26aa5e5141b3bfe0f8e739153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0d673ed7a2f11c26e4e119fa677939" id="r_ga8c0d673ed7a2f11c26e4e119fa677939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c0d673ed7a2f11c26e4e119fa677939">oslCreateImageCopy</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *src, int newLocation)</td></tr>
<tr class="separator:ga8c0d673ed7a2f11c26e4e119fa677939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7154173658c8a31552cd945715986a" id="r_gaff7154173658c8a31552cd945715986a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaff7154173658c8a31552cd945715986a">oslCreateSwizzledImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *src, int newLocation)</td></tr>
<tr class="separator:gaff7154173658c8a31552cd945715986a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b29865bab890a62315b7006fd6c9e26" id="r_ga5b29865bab890a62315b7006fd6c9e26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5b29865bab890a62315b7006fd6c9e26">oslCopyImageTo</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *imgDst, <a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *imgSrc)</td></tr>
<tr class="separator:ga5b29865bab890a62315b7006fd6c9e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga101016573d5cfb1a6f47522f27ee6d04" id="r_ga101016573d5cfb1a6f47522f27ee6d04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga101016573d5cfb1a6f47522f27ee6d04">oslSwizzleImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr class="separator:ga101016573d5cfb1a6f47522f27ee6d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2445885f9685c5c509d40b00e411bc2" id="r_gac2445885f9685c5c509d40b00e411bc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac2445885f9685c5c509d40b00e411bc2">oslUnswizzleImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr class="separator:gac2445885f9685c5c509d40b00e411bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfea3cb3ca4336e1b010b688ffc71813" id="r_gabfea3cb3ca4336e1b010b688ffc71813"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabfea3cb3ca4336e1b010b688ffc71813">oslSwizzleImageTo</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *imgDst, <a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *imgSrc)</td></tr>
<tr class="separator:gabfea3cb3ca4336e1b010b688ffc71813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ec01978617fdcbfc06771044990c6b" id="r_ga26ec01978617fdcbfc06771044990c6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga26ec01978617fdcbfc06771044990c6b">oslMoveImageTo</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, int newLocation)</td></tr>
<tr class="separator:ga26ec01978617fdcbfc06771044990c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa75c6d305e26d263e55bcdc1729532a7" id="r_gaa75c6d305e26d263e55bcdc1729532a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa75c6d305e26d263e55bcdc1729532a7">oslClearImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, int color)</td></tr>
<tr class="separator:gaa75c6d305e26d263e55bcdc1729532a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6684ace7bf87911969cdc4df5ac4f0b" id="r_gac6684ace7bf87911969cdc4df5ac4f0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac6684ace7bf87911969cdc4df5ac4f0b">oslWriteImageFile</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, const char *filename, int flags)</td></tr>
<tr class="separator:gac6684ace7bf87911969cdc4df5ac4f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f248a147693978616864ac3478c5d1b" id="r_ga0f248a147693978616864ac3478c5d1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0f248a147693978616864ac3478c5d1b">oslWriteImageFilePNG</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, const char *filename, int flags)</td></tr>
<tr class="separator:ga0f248a147693978616864ac3478c5d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b38db778d5abc94911e9be63b74c5e" id="r_gab7b38db778d5abc94911e9be63b74c5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab7b38db778d5abc94911e9be63b74c5e">oslResetImageProperties</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr class="separator:gab7b38db778d5abc94911e9be63b74c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb324d46ced2e9de9b29cd06e8123e58" id="r_gacb324d46ced2e9de9b29cd06e8123e58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacb324d46ced2e9de9b29cd06e8123e58">oslScaleImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *dstImg, <a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *srcImg, int newX, int newY, int newWidth, int newHeight)</td></tr>
<tr class="separator:gacb324d46ced2e9de9b29cd06e8123e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1588762ffb8ebd87a05310ccdb201b" id="r_ga9a1588762ffb8ebd87a05310ccdb201b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9a1588762ffb8ebd87a05310ccdb201b">oslScaleImageCreate</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, short newLocation, int newWidth, int newHeight, short newPixelFormat)</td></tr>
<tr class="separator:ga9a1588762ffb8ebd87a05310ccdb201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Image manipulation in OSLib. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga592a8dd6b6ebd9fe88af80034a1883eb" name="ga592a8dd6b6ebd9fe88af80034a1883eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga592a8dd6b6ebd9fe88af80034a1883eb">&#9670;&#160;</a></span>OSL_WRITE_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga592a8dd6b6ebd9fe88af80034a1883eb">OSL_WRITE_FLAGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum for specifying write flags when saving an image to a file. </p><pre class="fragment">The flags determine how the image data is processed when written to a file.
For example, flags can control whether the alpha channel is included in the output file.

@see oslWriteImageFilePNG for details on specific write flags.

@note Use these flags to customize the behavior of image writing functions.

\code
int flags = OSL_WRI_ALPHA; // Include alpha channel when writing the image
oslWriteImageFile(myImage, "output.png", flags);
\endcode
</pre> <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga592a8dd6b6ebd9fe88af80034a1883ebad97243719237d70adc2a619075d734a2" name="gga592a8dd6b6ebd9fe88af80034a1883ebad97243719237d70adc2a619075d734a2"></a>OSL_WRI_ALPHA&#160;</td><td class="fielddoc"><p>Writes the alpha channel of the image. If set, the alpha channel data will be included in the output file. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac87ef5c4f7054e7d7ce8c74dfeb65dfa" name="gac87ef5c4f7054e7d7ce8c74dfeb65dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac87ef5c4f7054e7d7ce8c74dfeb65dfa">&#9670;&#160;</a></span>oslCreateImageTile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> * oslCreateImageTile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offsetX0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offsetY0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offsetX1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offsetY1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an alternate image referencing a part (tile) of another one. </p><pre class="fragment">@param img
    The original image from which a tile will be created.
@param offsetX0
    The starting x position of the image part to reference.
@param offsetY0
    The starting y position of the image part to reference.
@param offsetX1
    The ending x position of the image part to reference.
@param offsetY1
    The ending y position of the image part to reference.

This will return a pointer to a new image, but the data will not be copied to the new image. Instead, it will reference the original
image data. When you delete the new image, the original image will be left unchanged; only the size of an `OSL_IMAGE` will be freed from memory
(about 80 bytes). However, if you delete the original image, the new one will be unusable. Attempting to draw it may result in corrupt data,
and writing to it may cause a crash.

Example usage:
\code
OSL_IMAGE *imageTile = oslCreateImageTile(originalImage, 0, 0, 32, 32);
oslDrawImage(imageTile);                                  // Will draw a 32x32 image inside of originalImage
oslDeleteImage(imageTile);                                // Only frees the copy, the original remains untouched!
\endcode

This routine was meant to create individual "sprite" images from a big one and manipulate them easily. However, as it's not very clear,
it's advised to avoid using it. An alternative approach would be:
\code
oslSetImageTile(originalImage, 0, 0, 32, 32);
oslDrawImage(originalImage);                              // Will draw a 32x32 image inside of originalImage
\endcode
</pre> 
</div>
</div>
<a id="ga82753be3adf49fa4bed8aaa0b43dd97a" name="ga82753be3adf49fa4bed8aaa0b43dd97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82753be3adf49fa4bed8aaa0b43dd97a">&#9670;&#160;</a></span>oslCreateImageTileSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> * oslCreateImageTileSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offsetX0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offsetY0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an alternate image referencing a part (tile) of another one using width and height. </p><pre class="fragment">@param img
    The original image from which a tile will be created.
@param offsetX0
    The starting x position of the image part to reference.
@param offsetY0
    The starting y position of the image part to reference.
@param width
    The width of the image part to reference.
@param height
    The height of the image part to reference.

This function returns a pointer to a new image, but the data will not be copied to the new image. Instead, it will reference the original
image data. When you delete the new image, the original image will be left unchanged; only the size of an `OSL_IMAGE` will be freed from memory
(about 80 bytes). However, if you delete the original image, the new one will be unusable. Attempting to draw it may result in corrupt data,
and writing to it may cause a crash.

Example usage:
\code
OSL_IMAGE *imageTile = oslCreateImageTileSize(originalImage, 0, 0, 32, 32);
oslDrawImage(imageTile);                                  // Will draw a 32x32 image inside of originalImage
oslDeleteImage(imageTile);                                // Only frees the copy, the original remains untouched!
\endcode

This routine was designed to create individual "sprite" images from a large image using width and height specifications. An alternative approach
for creating image tiles is using coordinates with the `oslSetImageTile` function.
</pre> 
</div>
</div>
<a id="ga45d537c26aa5e5141b3bfe0f8e739153" name="ga45d537c26aa5e5141b3bfe0f8e739153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d537c26aa5e5141b3bfe0f8e739153">&#9670;&#160;</a></span>oslConvertImageTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> * oslConvertImageTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>imgOriginal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newLocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newFormat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an image to another pixel format and places it in another location. </p><pre class="fragment">@param imgOriginal
    The original image to be converted.
@param newLocation
    The location where the converted image should be placed. Common locations include `OSL_IN_RAM` and `OSL_IN_VRAM`.
@param newFormat
    The pixel format to convert the image to, such as `OSL_PF_5551`, `OSL_PF_8888`, etc.

This function converts an image to a different pixel format and places it in a specified location. The original image may have been moved or modified
during the conversion process, so you should use the returned image instead of the original one.

Example usage:
\code
image = oslConvertImageTo(image, OSL_IN_RAM, OSL_PF_5551);
\endcode

After calling this function, the `imgOriginal` image should no longer be used directly. Instead, the function returns a new image with the specified
pixel format and location. Ensure to properly manage and delete the converted image as needed.
</pre> 
</div>
</div>
<a id="ga8c0d673ed7a2f11c26e4e119fa677939" name="ga8c0d673ed7a2f11c26e4e119fa677939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0d673ed7a2f11c26e4e119fa677939">&#9670;&#160;</a></span>oslCreateImageCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> * oslCreateImageCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newLocation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a copy of an image. </p><pre class="fragment">@param src
    The source image to be copied.
@param newLocation
    The location where the copied image should be placed. Common locations include `OSL_IN_RAM` and `OSL_IN_VRAM`.

This function creates a complete copy of the source image, including its image data. The returned image is a new instance, independent of the original. Changes to the copied image will not affect the source image and vice versa.

Example usage:
\code
OSL_IMAGE *originalImage = oslLoadImageFile("example.png", OSL_IN_RAM, OSL_PF_8888);
OSL_IMAGE *copiedImage = oslCreateImageCopy(originalImage, OSL_IN_VRAM);
// Now you can use copiedImage independently of originalImage
\endcode

Both the original and copied images are not linked together. Ensure to manage and free the memory for both images as needed.
</pre> 
</div>
</div>
<a id="gaff7154173658c8a31552cd945715986a" name="gaff7154173658c8a31552cd945715986a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff7154173658c8a31552cd945715986a">&#9670;&#160;</a></span>oslCreateSwizzledImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> * oslCreateSwizzledImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newLocation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a copy of an image and swizzles the new one. </p><pre class="fragment">@param src
    The source image to be copied.
@param newLocation
    The location where the swizzled image should be placed. Common locations include `OSL_IN_RAM` and `OSL_IN_VRAM`.

This function creates a complete copy of the source image and applies swizzling to the new image. Swizzling is a technique used to improve texture performance by rearranging the image data. The returned image is a new instance, independent of the original.

Example usage:
\code
OSL_IMAGE *originalImage = oslLoadImageFile("example.png", OSL_IN_RAM, OSL_PF_8888);
OSL_IMAGE *swizzledImage = oslCreateSwizzledImage(originalImage, OSL_IN_VRAM);
// Now you can use swizzledImage independently of originalImage
\endcode

Both the original and swizzled images are not linked together. Ensure to manage and free the memory for both images as needed.
</pre> 
</div>
</div>
<a id="ga5b29865bab890a62315b7006fd6c9e26" name="ga5b29865bab890a62315b7006fd6c9e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b29865bab890a62315b7006fd6c9e26">&#9670;&#160;</a></span>oslCopyImageTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslCopyImageTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>imgDst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>imgSrc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the content of one image to another. </p><pre class="fragment">@param imgDst
    The destination image where the content will be copied to.
@param imgSrc
    The source image from which the content will be copied.

This function copies the image data from `imgSrc` to `imgDst`. Both images must have the same dimensions (width and height) and pixel format. If the formats do not match, the copy operation will fail, and the destination image may not be updated correctly.

Note: This function only copies the image data and does not change the properties of `imgDst`. Ensure that `imgDst` has been properly initialized and allocated with the same format and size as `imgSrc`.

Example usage:
\code
OSL_IMAGE *sourceImage = oslLoadImageFile("source.png", OSL_IN_RAM, OSL_PF_8888);
OSL_IMAGE *destinationImage = oslCreateImage(sourceImage-&gt;sizeX, sourceImage-&gt;sizeY, OSL_IN_RAM, OSL_PF_8888);
oslCopyImageTo(destinationImage, sourceImage);
// Now destinationImage contains a copy of the sourceImage data
\endcode

Ensure both images have the same properties before calling this function to avoid unexpected behavior.
</pre> 
</div>
</div>
<a id="ga101016573d5cfb1a6f47522f27ee6d04" name="ga101016573d5cfb1a6f47522f27ee6d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga101016573d5cfb1a6f47522f27ee6d04">&#9670;&#160;</a></span>oslSwizzleImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslSwizzleImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swizzles an image to improve drawing performance. </p><pre class="fragment">@param img
    The image to be swizzled.

Swizzling is a process that optimizes image drawing performance by reorganizing the image data into a format that is more efficient for the GPU to handle. After swizzling, the image can be drawn much faster. However, swizzled images cannot be modified directly due to their special format.

If you need to modify the image after swizzling, you will need to unswizzle it, which can be slow. Therefore, it is recommended to swizzle images that are stored in RAM and are not intended to be modified frequently.

Hint: When loading images, use the `OSL_SWIZZLED` bit to automatically swizzle images for convenience.

Example usage:
\code
OSL_IMAGE *image = oslLoadImageFile("example.png", OSL_IN_RAM, OSL_PF_8888);
oslSwizzleImage(image);
// The image is now swizzled and can be drawn faster
\endcode

Be cautious with unswizzling images frequently, as it can impact performance. Use swizzling for images that are primarily used for rendering and do not require modifications.
</pre> 
</div>
</div>
<a id="gac2445885f9685c5c509d40b00e411bc2" name="gac2445885f9685c5c509d40b00e411bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2445885f9685c5c509d40b00e411bc2">&#9670;&#160;</a></span>oslUnswizzleImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslUnswizzleImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Restores an image from its swizzled format to its original format. </p><pre class="fragment">@param img
    The swizzled image to be unswizzled.

This function performs the opposite operation of `oslSwizzleImage`, converting the swizzled image back to its original format. After unswizzling, the image will be accessible for raw reading and writing.

Note that unswizzling an image can be a slow process, so it should be used judiciously. It's generally best to swizzle images for performance improvements and avoid frequent unswizzling unless necessary.

Example usage:
\code
OSL_IMAGE *swizzledImage = oslLoadImageFile("example.png", OSL_IN_RAM, OSL_PF_8888);
oslSwizzleImage(swizzledImage);
// Use the image for fast drawing
oslUnswizzleImage(swizzledImage);
// Now you can read or write to the image directly
\endcode

Make sure to only unswizzle images that were previously swizzled to avoid potential issues with image data integrity.
</pre> 
</div>
</div>
<a id="gabfea3cb3ca4336e1b010b688ffc71813" name="gabfea3cb3ca4336e1b010b688ffc71813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfea3cb3ca4336e1b010b688ffc71813">&#9670;&#160;</a></span>oslSwizzleImageTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslSwizzleImageTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>imgDst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>imgSrc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swizzles an image and writes the result to another image. </p><pre class="fragment">@param imgDst
    The destination image where the swizzled data will be written. This image must have enough memory allocated to hold the swizzled data.
@param imgSrc
    The source image that will be swizzled.

This function swizzles the `imgSrc` image and writes the swizzled result to `imgDst`. This routine is considered outdated. For modern usage, it is recommended to use `oslSwizzleImage` which operates directly on a single image.

Example usage:
\code
OSL_IMAGE *sourceImage = oslLoadImageFile("example.png", OSL_IN_RAM, OSL_PF_8888);
OSL_IMAGE *destinationImage = oslCreateImage(sourceImage-&gt;sizeX, sourceImage-&gt;sizeY, OSL_PF_8888);
oslSwizzleImageTo(destinationImage, sourceImage);
// Use destinationImage for fast drawing
\endcode

Note: Ensure that `imgDst` has been properly allocated and has sufficient size to accommodate the swizzled image data from `imgSrc`.
</pre> 
</div>
</div>
<a id="ga26ec01978617fdcbfc06771044990c6b" name="ga26ec01978617fdcbfc06771044990c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26ec01978617fdcbfc06771044990c6b">&#9670;&#160;</a></span>oslMoveImageTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool oslMoveImageTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newLocation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves an image to a new location in memory. </p><pre class="fragment">@param img
    The image to be moved.
@param newLocation
    The new location where the image should be moved. This can be either `OSL_IN_RAM` or `OSL_IN_VRAM`.

This function relocates an image to a new memory location. The new location can be either RAM or VRAM. After moving, the image can be used in its new location, but note that moving images between different memory types might have implications for performance and accessibility.

Example usage:
\code
OSL_IMAGE *image = oslLoadImageFile("example.png", OSL_IN_RAM, OSL_PF_8888);
oslMoveImageTo(image, OSL_IN_VRAM);
// Now the image is in VRAM and can be used for rendering
\endcode

Returns `true` if the move was successful, and `false` otherwise.
</pre> 
</div>
</div>
<a id="gaa75c6d305e26d263e55bcdc1729532a7" name="gaa75c6d305e26d263e55bcdc1729532a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa75c6d305e26d263e55bcdc1729532a7">&#9670;&#160;</a></span>oslClearImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslClearImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>color</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears an image with a specific value. </p><pre class="fragment">@param img
    The image to be cleared. This image must be properly allocated and must have a format compatible with the provided color value.
@param color
    The color value used to clear the image. The format of this color value depends on the pixel format of the image. For example:
    - If the image format is `OSL_PF_4BIT`, the color value is a palette entry number.
    - If the image format is `OSL_PF_5551`, the color value is a 15-bit color with alpha.

This function fills the entire image with the specified color value. The color is applied according to the image's pixel format. For instance, in a `OSL_PF_4444` format, you might use a 16-bit color value where each channel has 4 bits.

Example usage:
\code
OSL_IMAGE *img = oslCreateImage(32, 32, OSL_IN_RAM, OSL_PF_4444);
// Clear the image to black with full opacity (alpha=255)
oslClearImage(img, RGBA12(0, 0, 0, 255));
\endcode

Note: The `color` parameter must be appropriate for the image's pixel format. The provided value should match the format's bit depth and channel order.
</pre> 
</div>
</div>
<a id="gac6684ace7bf87911969cdc4df5ac4f0b" name="gac6684ace7bf87911969cdc4df5ac4f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6684ace7bf87911969cdc4df5ac4f0b">&#9670;&#160;</a></span>oslWriteImageFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oslWriteImageFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes an image to a file. </p><pre class="fragment">@param img
    The image to be written to the file. This image must not be swizzled; if it is, the function will not perform any operation.
@param filename
    The path to the file where the image will be saved. The file type is determined based on the file extension.
@param flags
    Options for the image writing operation. These flags control how the image is processed during writing. The specific flags available depend on the implementation and version of OSLib.

@return
    Returns a status code indicating the success or failure of the operation. The exact values and meaning of the return codes depend on the implementation.

This function saves the provided image to the specified file. The file type is automatically detected based on the file extension, which includes support for various formats. However, using this function can increase the size of your project and use unnecessary RAM because it supports every possible format.

\b Note: If the image is swizzled, the function will not perform any action. To write a swizzled image, you must first unswizzle it using the #oslUnswizzleImage function.

Example usage:
\code
OSL_IMAGE *img = oslCreateImage(64, 64, OSL_IN_RAM, OSL_PF_5551);
// Assuming img is properly initialized and contains image data
int result = oslWriteImageFile(img, "output_image.png", 0);
if (result == 0) {
    // Image was written successfully
} else {
    // Error occurred
}
\endcode
</pre> 
</div>
</div>
<a id="ga0f248a147693978616864ac3478c5d1b" name="ga0f248a147693978616864ac3478c5d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f248a147693978616864ac3478c5d1b">&#9670;&#160;</a></span>oslWriteImageFilePNG()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oslWriteImageFilePNG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes an image to a PNG file. Same remarks as oslWriteImageFile apply. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image you want to write. </td></tr>
    <tr><td class="paramname">filename</td><td>The name of the file that you want to write to. </td></tr>
    <tr><td class="paramname">flags</td><td>Either 0 or OSL_WRI_ALPHA. If OSL_WRI_ALPHA is specified, the alpha will be written to the PNG image file, making it semi-transparent. Else, alpha is ignored and always set to opaque.</td></tr>
  </table>
  </dd>
</dl>
<p>You can pass for example OSL_SECONDARY_BUFFER (the buffer which is currently displayed on the screen) to take a screenshot. </p><div class="fragment"><div class="line"><a class="code hl_function" href="#ga0f248a147693978616864ac3478c5d1b">oslWriteImageFilePNG</a>(<a class="code hl_define" href="group__image__drawbuf.html#gac1fd66db227dedd5ba7916f6cfc6045b">OSL_SECONDARY_BUFFER</a>, <span class="stringliteral">&quot;screenshot.png&quot;</span>, 0);</div>
<div class="ttc" id="agroup__image__drawbuf_html_gac1fd66db227dedd5ba7916f6cfc6045b"><div class="ttname"><a href="group__image__drawbuf.html#gac1fd66db227dedd5ba7916f6cfc6045b">OSL_SECONDARY_BUFFER</a></div><div class="ttdeci">#define OSL_SECONDARY_BUFFER</div><div class="ttdef"><b>Definition</b> drawing.h:2946</div></div>
<div class="ttc" id="agroup__image__manip_html_ga0f248a147693978616864ac3478c5d1b"><div class="ttname"><a href="#ga0f248a147693978616864ac3478c5d1b">oslWriteImageFilePNG</a></div><div class="ttdeci">int oslWriteImageFilePNG(OSL_IMAGE *img, const char *filename, int flags)</div></div>
</div><!-- fragment --><p><b>Note:</b> The same considerations as <a class="el" href="#gac6684ace7bf87911969cdc4df5ac4f0b">oslWriteImageFile</a> apply. </p>

</div>
</div>
<a id="gab7b38db778d5abc94911e9be63b74c5e" name="gab7b38db778d5abc94911e9be63b74c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7b38db778d5abc94911e9be63b74c5e">&#9670;&#160;</a></span>oslResetImageProperties()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslResetImageProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the properties of an image, including its position, tile settings, angle, rotation center, and stretching. </p><pre class="fragment">@param img
    The image whose properties will be reset.

This function resets the following properties of the image:
- Position: The image's current position will be reset to its default.
- Image Tile: Any modifications to the image tile (e.g., using `oslSetImageTile`) will be cleared.
- Angle: Any rotation applied to the image will be reset.
- Rotation Center: The center used for rotation will be reset.
- Stretching: Any stretching applied to the image will be reset.

Example usage:
\code
OSL_IMAGE *img = oslCreateImage(64, 64, OSL_IN_RAM, OSL_PF_5551);
// Modify image properties
oslResetImageProperties(img);
\endcode
</pre> 
</div>
</div>
<a id="gacb324d46ced2e9de9b29cd06e8123e58" name="gacb324d46ced2e9de9b29cd06e8123e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb324d46ced2e9de9b29cd06e8123e58">&#9670;&#160;</a></span>oslScaleImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslScaleImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>dstImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>srcImg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newHeight</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws srcImg to dstImg with scaling applied. </p><pre class="fragment">@param dstImg
    The destination image where the scaled source image will be drawn.
@param srcImg
    The source image to be scaled and drawn.
@param newX
    The x-coordinate for the position of the scaled source image in the destination image.
@param newY
    The y-coordinate for the position of the scaled source image in the destination image.
@param newWidth
    The width of the scaled source image.
@param newHeight
    The height of the scaled source image.

This function scales the source image (srcImg) and draws it onto the destination image (dstImg) at the specified position and with the specified dimensions.

Example usage:
\code
OSL_IMAGE *srcImg = oslCreateImage(64, 64, OSL_IN_RAM, OSL_PF_5551);
OSL_IMAGE *dstImg = oslCreateImage(128, 128, OSL_IN_RAM, OSL_PF_5551);
// Scale and draw srcImg onto dstImg
oslScaleImage(dstImg, srcImg, 10, 10, 100, 100);
\endcode
</pre> 
</div>
</div>
<a id="ga9a1588762ffb8ebd87a05310ccdb201b" name="ga9a1588762ffb8ebd87a05310ccdb201b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a1588762ffb8ebd87a05310ccdb201b">&#9670;&#160;</a></span>oslScaleImageCreate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> * oslScaleImageCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short</td>          <td class="paramname"><span class="paramname"><em>newLocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newWidth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newHeight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short</td>          <td class="paramname"><span class="paramname"><em>newPixelFormat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a scaled copy of an image. </p><pre class="fragment">@param img
    The image to be scaled and copied.
@param newLocation
    The location where the new scaled image will be stored (e.g., in RAM or VRAM).
@param newWidth
    The width of the scaled image.
@param newHeight
    The height of the scaled image.
@param newPixelFormat
    The pixel format of the new scaled image.

@return
    A pointer to the new scaled image. If the scaling operation fails, the function may return NULL.

This function creates a new image that is a scaled version of the original image (img). The new image will have the specified dimensions and pixel format.

Example usage:
\code
OSL_IMAGE *originalImg = oslCreateImage(64, 64, OSL_IN_RAM, OSL_PF_5551);
OSL_IMAGE *scaledImg = oslScaleImageCreate(originalImg, OSL_IN_RAM, 128, 128, OSL_PF_5551);
\endcode
</pre> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
