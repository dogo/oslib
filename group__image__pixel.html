<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OldSchool Library: Pixel access</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">OldSchool Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__image__pixel.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Pixel access<div class="ingroups"><a class="el" href="group__drawing__adv.html">Advanced</a> &raquo; <a class="el" href="group__image.html">Images</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2abc6cfb0fa391142551f86488599289" id="r_ga2abc6cfb0fa391142551f86488599289"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2abc6cfb0fa391142551f86488599289">oslGetImageLine</a>(img,  y)</td></tr>
<tr class="separator:ga2abc6cfb0fa391142551f86488599289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd9c6315b59af4be74346c54b73f0c1" id="r_gaadd9c6315b59af4be74346c54b73f0c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaadd9c6315b59af4be74346c54b73f0c1">oslGetImagePixelAddr</a>(img,  x,  y)</td></tr>
<tr class="separator:gaadd9c6315b59af4be74346c54b73f0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga839af73e582e99090685daa99ef732ef" id="r_ga839af73e582e99090685daa99ef732ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga839af73e582e99090685daa99ef732ef">oslGetImagePixelAdr</a>&#160;&#160;&#160;<a class="el" href="#gaadd9c6315b59af4be74346c54b73f0c1">oslGetImagePixelAddr</a></td></tr>
<tr class="separator:ga839af73e582e99090685daa99ef732ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga789fb4f5321897634fddb3aa14e7d6e9" id="r_ga789fb4f5321897634fddb3aa14e7d6e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga789fb4f5321897634fddb3aa14e7d6e9">oslUncacheImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr class="separator:ga789fb4f5321897634fddb3aa14e7d6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17750f92f8395b04b76cd58d3332c5d" id="r_gaa17750f92f8395b04b76cd58d3332c5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa17750f92f8395b04b76cd58d3332c5d">oslGetImagePixel</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, unsigned int x, unsigned int y)</td></tr>
<tr class="separator:gaa17750f92f8395b04b76cd58d3332c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa20f8d50de53edf75802faf747b2aa66" id="r_gaa20f8d50de53edf75802faf747b2aa66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa20f8d50de53edf75802faf747b2aa66">oslSetImagePixel</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, unsigned int x, unsigned int y, int pixelValue)</td></tr>
<tr class="separator:gaa20f8d50de53edf75802faf747b2aa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa062b564dada15dcfff6caa3e955fe0" id="r_gaaa062b564dada15dcfff6caa3e955fe0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaa062b564dada15dcfff6caa3e955fe0">oslGetSwizzledPixelAddr</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img, unsigned int x, unsigned int y)</td></tr>
<tr class="separator:gaaa062b564dada15dcfff6caa3e955fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac444b3ad613929f5bce6da775f574197" id="r_gac444b3ad613929f5bce6da775f574197"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac444b3ad613929f5bce6da775f574197">oslConvertColor</a> (int pfDst, int pfSrc, int color)</td></tr>
<tr class="memdesc:gac444b3ad613929f5bce6da775f574197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a color from one pixel format to another.  <br /></td></tr>
<tr class="separator:gac444b3ad613929f5bce6da775f574197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga767b891aec656ada10b5c8163a9d0e96" id="r_ga767b891aec656ada10b5c8163a9d0e96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga767b891aec656ada10b5c8163a9d0e96">oslConvertColorEx</a> (<a class="el" href="struct_o_s_l___p_a_l_e_t_t_e.html">OSL_PALETTE</a> *p, int pfDst, int pfSrc, int color)</td></tr>
<tr class="memdesc:ga767b891aec656ada10b5c8163a9d0e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a color between different pixel formats, optionally using a palette for indexed formats.  <br /></td></tr>
<tr class="separator:ga767b891aec656ada10b5c8163a9d0e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e009683f250dbeeeb7d8cb304b58ddd" id="r_ga1e009683f250dbeeeb7d8cb304b58ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1e009683f250dbeeeb7d8cb304b58ddd">oslLockImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr class="separator:ga1e009683f250dbeeeb7d8cb304b58ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga483de8582f4bdf0ec946e16f0cbd8856" id="r_ga483de8582f4bdf0ec946e16f0cbd8856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga483de8582f4bdf0ec946e16f0cbd8856">oslUnlockImage</a> (<a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img)</td></tr>
<tr class="separator:ga483de8582f4bdf0ec946e16f0cbd8856"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae84026314c01744128932407470bc75b" id="r_gae84026314c01744128932407470bc75b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae84026314c01744128932407470bc75b">osl_pixelWidth</a> []</td></tr>
<tr class="separator:gae84026314c01744128932407470bc75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e1b4c623f2ee9591b1b5ee098decb9" id="r_ga99e1b4c623f2ee9591b1b5ee098decb9"><td class="memItemLeft" align="right" valign="top">const u8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga99e1b4c623f2ee9591b1b5ee098decb9">osl_paletteSizes</a> []</td></tr>
<tr class="separator:ga99e1b4c623f2ee9591b1b5ee098decb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Low-level access to images. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga2abc6cfb0fa391142551f86488599289" name="ga2abc6cfb0fa391142551f86488599289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2abc6cfb0fa391142551f86488599289">&#9670;&#160;</a></span>oslGetImageLine</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslGetImageLine</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<span class="keywordtype">char</span> *)((img)-&gt;data) + (y) * (((img)-&gt;realSizeX * <a class="code hl_variable" href="#gae84026314c01744128932407470bc75b">osl_pixelWidth</a>[(img)-&gt;pixelFormat]) &gt;&gt; 3))</div>
<div class="ttc" id="agroup__image__pixel_html_gae84026314c01744128932407470bc75b"><div class="ttname"><a href="#gae84026314c01744128932407470bc75b">osl_pixelWidth</a></div><div class="ttdeci">const int osl_pixelWidth[]</div></div>
</div><!-- fragment --><p>Returns the address of the beginning (left border) of a specific line in an image. </p><pre class="fragment">This macro provides access to the raw data of a specific line in the image. When using this macro, make sure to respect the pixel format of the image. For images with 16-bit pixel formats (e.g., 4444, 5551, or 5650), use a `u16` pointer and the appropriate RGBxx macros for accessing pixel values.

@param img
    Pointer to the image from which the line address is obtained.
@param y
    The line number (0 is the first line, 1 is the second, and so on).

@return
    A pointer to the beginning of the specified line in the image's raw data.

\b Example:
\code
// Create a 15-bit image (16-bit pixel width, with 1 alpha bit included)
OSL_IMAGE *img = oslCreateImage(32, 32, OSL_IN_RAM, OSL_PF_5551);

// Get a pointer to the 4th line (0-based index)
u16 *data = (u16*)oslGetImageLine(img, 3);

// Loop through each pixel in the line
for (int i = 0; i &lt; img-&gt;sizeX; i++) {
    // Set this pixel to bright red
         *data = RGBA15(255, 0, 0, 255);
    // Move to the next pixel
    data++;
}
\endcode

\b Note:
- Ensure you use the correct pixel format and data type when accessing raw image data.
</pre> 
</div>
</div>
<a id="gaadd9c6315b59af4be74346c54b73f0c1" name="gaadd9c6315b59af4be74346c54b73f0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadd9c6315b59af4be74346c54b73f0c1">&#9670;&#160;</a></span>oslGetImagePixelAddr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslGetImagePixelAddr</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<span class="keywordtype">char</span> *)((img)-&gt;data) + ((((y) * (img)-&gt;realSizeX + (x)) * <a class="code hl_variable" href="#gae84026314c01744128932407470bc75b">osl_pixelWidth</a>[(img)-&gt;pixelFormat]) &gt;&gt; 3))</div>
</div><!-- fragment --><p>Gets the address of a single pixel in an image. </p><pre class="fragment">This macro provides a pointer to the address of a specific pixel in the image. It is designed to work with pixel formats ranging from 8 to 32 bits per pixel. Note that this macro does not handle 4-bit images correctly, as a byte in 4-bit images represents two pixels. For 4-bit images, this macro returns a pointer to the corresponding byte, and additional bit manipulation is required to access individual pixels.

@param img
    Pointer to the image from which to retrieve the pixel address.
@param x
    The x-coordinate of the pixel.
@param y
    The y-coordinate of the pixel.

@return
    A pointer to the address of the specified pixel in the image's raw data.

\b Example:
\code
void setPixel(OSL_IMAGE *img, int x, int y, int value) {
    u8 *data = (u8 *)oslGetImagePixelAddr(img, x, y);

    // Ensure the pixel value does not exceed the bit depth
    value &amp;= 0xf;

    // Handle 4-bit images by checking if x is even or odd
    if (x &amp; 1) {
            // Mask out the last 4 bits
                 *data &amp;= 0x0f;
            // Write to the last 4 bits
                 *data |= value &lt;&lt; 4;
    } else {
            // Mask out the first 4 bits
                 *data &amp;= 0xf0;
            // Write to the first 4 bits
                 *data |= value;
    }

    // Alternative method with parity checking
         *data &amp;= ~(15 &lt;&lt; ((x &amp; 1) &lt;&lt; 2));
         *data |= value &lt;&lt; ((x &amp; 1) &lt;&lt; 2);
}
\endcode

\b Note:
- Ensure that you handle the pixel data according to its format and bit depth. For 4-bit images, additional bit manipulation is required.
</pre> 
</div>
</div>
<a id="ga839af73e582e99090685daa99ef732ef" name="ga839af73e582e99090685daa99ef732ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga839af73e582e99090685daa99ef732ef">&#9670;&#160;</a></span>oslGetImagePixelAdr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oslGetImagePixelAdr&#160;&#160;&#160;<a class="el" href="#gaadd9c6315b59af4be74346c54b73f0c1">oslGetImagePixelAddr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For backward compatibility. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga789fb4f5321897634fddb3aa14e7d6e9" name="ga789fb4f5321897634fddb3aa14e7d6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga789fb4f5321897634fddb3aa14e7d6e9">&#9670;&#160;</a></span>oslUncacheImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslUncacheImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uncaches an entire image, including its associated palette. </p><pre class="fragment">This function not only flushes the image data from the cache but also handles the associated palette data, ensuring that both are properly uncached.

@param img
    Pointer to the image to be uncached.

\b Note:
- This routine is a comprehensive solution for ensuring that all parts of the image (data and palette) are properly managed in memory.

\code
OSL_IMAGE *img = your image;
oslUncacheImage(img); // Flushes image data and associated palette
\endcode
</pre> 
</div>
</div>
<a id="gaa17750f92f8395b04b76cd58d3332c5d" name="gaa17750f92f8395b04b76cd58d3332c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa17750f92f8395b04b76cd58d3332c5d">&#9670;&#160;</a></span>oslGetImagePixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oslGetImagePixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>High-level routine to read a single pixel from an image. </p><pre class="fragment">This function retrieves the value of a pixel at a specified position from an image. Note that caching is enabled, so after reading and/or writing pixels, you should uncache the image. The recommended approach is to use #oslLockImage and #oslUnlockImage for proper management. For an example of usage, see #oslGetImagePixel.

@param img
    Pointer to the image from which the pixel is read.
@param x
    The x-coordinate of the pixel to be read.
@param y
    The y-coordinate of the pixel to be read.

@return
    The value of the pixel at the specified position. The returned value depends on the pixel format of the image. It could be a palette entry number for paletted images or a color value in the image's format. You might need to convert this value depending on your needs.

\b Example:
\code
// Get a 32-bit (OSL_PF_8888) color for the pixel at x, y, regardless of the image's pixel format.
int pixel = oslConvertColorEx(yourImage-&gt;palette, OSL_PF_8888, yourImage-&gt;pixelFormat, oslGetImagePixel(yourImage, x, y));
\endcode

\b Note:
- This function works for both regular and swizzled images.
- It may be slower compared to raw access methods; consider using raw access if performance is critical.
</pre> 
</div>
</div>
<a id="gaa20f8d50de53edf75802faf747b2aa66" name="gaa20f8d50de53edf75802faf747b2aa66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa20f8d50de53edf75802faf747b2aa66">&#9670;&#160;</a></span>oslSetImagePixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslSetImagePixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pixelValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a pixel value on the image. </p><pre class="fragment">This function sets the value of a pixel at a specified position in the image. The value should be in the image's destination format, which could be a palette entry or a color value. If needed, perform conversions to match the image's format.

@param img
    Pointer to the image where the pixel will be set.
@param x
    The x-coordinate of the pixel to be set.
@param y
    The y-coordinate of the pixel to be set.
@param pixelValue
    The value to set at the specified pixel position. This value should be in the format used by the image (e.g., a color value or a palette entry).

\b Example:
\code
// Before performing low-level operations on an image, lock it to handle cache operations.
oslLockImage(image);
{
    // Iterate over all pixels in the image
    for (j = 0; j &lt; image-&gt;sizeY; j++) {
            for (i = 0; i &lt; image-&gt;sizeX; i++) {
                    // Get the current pixel value (assuming a 8888 format here)
                    u32 pixel = oslGetImagePixel(image, i, j);
                    // Mask out the green and blue components
                    oslSetImagePixel(image, i, j, pixel &amp; 0xff0000ff);
            }
    }
}
oslUnlockImage(image);
\endcode

\b Note:
- Similar caching considerations apply as with #oslGetImagePixel. Make sure to manage the image cache properly by locking and unlocking the image.
</pre> 
</div>
</div>
<a id="gaaa062b564dada15dcfff6caa3e955fe0" name="gaaa062b564dada15dcfff6caa3e955fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa062b564dada15dcfff6caa3e955fe0">&#9670;&#160;</a></span>oslGetSwizzledPixelAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * oslGetSwizzledPixelAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of a pixel, even if the image is swizzled. This implementation is slower but works in every case, including swizzled images.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>Pointer to the <a class="el" href="struct_o_s_l___i_m_a_g_e.html" title="Structure representing an image loaded in memory.">OSL_IMAGE</a> structure representing the image. </td></tr>
    <tr><td class="paramname">x</td><td>The x-coordinate of the pixel. </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the pixel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the address of the pixel in the image's raw data. The exact type of this pointer depends on the image's pixel format and needs to be cast appropriately.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is designed to handle swizzled images. It might be slower than direct access methods, but it ensures correct behavior for swizzled images by accounting for the swizzling pattern.</dd></dl>
<div class="fragment"><div class="line"> <span class="comment">// Example usage:</span></div>
<div class="line"> <a class="code hl_struct" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *img = Load or create your image;</div>
<div class="line"><span class="keywordtype">void</span> *pixelAddr = <a class="code hl_function" href="#gaaa062b564dada15dcfff6caa3e955fe0">oslGetSwizzledPixelAddr</a>(img, x, y);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Depending on the pixel format, cast the pointer to the appropriate type</span></div>
<div class="line">u32 *pixelData = (u32*)pixelAddr;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can read or modify the pixel data</span></div>
<div class="line">*pixelData = New pixel value;</div>
<div class="ttc" id="agroup__image__pixel_html_gaaa062b564dada15dcfff6caa3e955fe0"><div class="ttname"><a href="#gaaa062b564dada15dcfff6caa3e955fe0">oslGetSwizzledPixelAddr</a></div><div class="ttdeci">void * oslGetSwizzledPixelAddr(OSL_IMAGE *img, unsigned int x, unsigned int y)</div></div>
<div class="ttc" id="astruct_o_s_l___i_m_a_g_e_html"><div class="ttname"><a href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a></div><div class="ttdoc">Structure representing an image loaded in memory.</div><div class="ttdef"><b>Definition</b> drawing.h:927</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gac444b3ad613929f5bce6da775f574197" name="gac444b3ad613929f5bce6da775f574197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac444b3ad613929f5bce6da775f574197">&#9670;&#160;</a></span>oslConvertColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oslConvertColor </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pfDst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pfSrc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>color</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a color from one pixel format to another. </p>
<p>This function converts a color value from the source pixel format (<code>pfSrc</code>) to the destination pixel format (<code>pfDst</code>). It supports various pixel formats, including <code>OSL_PF_8888</code>, <code>OSL_PF_5650</code>, <code>OSL_PF_5551</code>, and <code>OSL_PF_4444</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfDst</td><td>The destination pixel format. This can be one of the <code>OSL_PF_*</code> values (e.g., <code>OSL_PF_8888</code>, <code>OSL_PF_5650</code>). </td></tr>
    <tr><td class="paramname">pfSrc</td><td>The source pixel format. This can be one of the <code>OSL_PF_*</code> values (e.g., <code>OSL_PF_8888</code>, <code>OSL_PF_5650</code>). </td></tr>
    <tr><td class="paramname">color</td><td>The color value to be converted, expressed in the source pixel format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The color converted to the destination pixel format. </dd></dl>

</div>
</div>
<a id="ga767b891aec656ada10b5c8163a9d0e96" name="ga767b891aec656ada10b5c8163a9d0e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga767b891aec656ada10b5c8163a9d0e96">&#9670;&#160;</a></span>oslConvertColorEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int oslConvertColorEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___p_a_l_e_t_t_e.html">OSL_PALETTE</a> *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pfDst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pfSrc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>color</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a color between different pixel formats, optionally using a palette for indexed formats. </p>
<p>This function converts a color from one pixel format (<code>pfSrc</code>) to another (<code>pfDst</code>). If either the source or destination format is a paletted format (<code>OSL_PF_8BIT</code> or <code>OSL_PF_4BIT</code>), the provided palette (<code>p</code>) will be used for the conversion.</p>
<dl class="section note"><dt>Note</dt><dd>If the source and destination formats are the same, the original color is returned without modification.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to an <code><a class="el" href="struct_o_s_l___p_a_l_e_t_t_e.html" title="Structure representing a palette.">OSL_PALETTE</a></code> structure. This is used when the source or destination format is paletted. If <code>p</code> is <code>NULL</code>, the conversion will be done without using a palette. </td></tr>
    <tr><td class="paramname">pfDst</td><td>The destination pixel format. This can be any of the <code>OSL_PF_*</code> values (e.g., <code>OSL_PF_8888</code>, <code>OSL_PF_5650</code>). </td></tr>
    <tr><td class="paramname">pfSrc</td><td>The source pixel format. This can be any of the <code>OSL_PF_*</code> values (e.g., <code>OSL_PF_8888</code>, <code>OSL_PF_5650</code>). </td></tr>
    <tr><td class="paramname">color</td><td>The color value to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The color converted to the destination pixel format. </dd></dl>

</div>
</div>
<a id="ga1e009683f250dbeeeb7d8cb304b58ddd" name="ga1e009683f250dbeeeb7d8cb304b58ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e009683f250dbeeeb7d8cb304b58ddd">&#9670;&#160;</a></span>oslLockImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslLockImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Locks an image to ensure safe access and modifications. This function automatically handles drawing to the drawbuffer, uncaching the image when finished, and flushing the texture cache to avoid rendering issues when the image is modified during drawing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>Pointer to the <a class="el" href="struct_o_s_l___i_m_a_g_e.html" title="Structure representing an image loaded in memory.">OSL_IMAGE</a> structure representing the image to lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>While locking an image is not strictly necessary, it is highly recommended as it ensures proper management of image access and rendering, preventing potential errors caused by concurrent modifications and drawing operations.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Lock the image to safely modify it</span></div>
<div class="line"><a class="code hl_function" href="#ga1e009683f250dbeeeb7d8cb304b58ddd">oslLockImage</a>(myImage);</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Perform software access and modification to the image</span></div>
<div class="line">    u16 *ptr = (u16*)myImage-&gt;data;</div>
<div class="line">    *ptr = 0; <span class="comment">// Example modification</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// Unlock the image after modifications are complete</span></div>
<div class="line"><a class="code hl_function" href="#ga483de8582f4bdf0ec946e16f0cbd8856">oslUnlockImage</a>(myImage);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now you can safely draw the modified image</span></div>
<div class="line"><a class="code hl_function" href="group__image__drawing.html#gaf6b7b3f250d1fd2d961d55686528a276">oslDrawImage</a>(myImage);</div>
<div class="ttc" id="agroup__image__drawing_html_gaf6b7b3f250d1fd2d961d55686528a276"><div class="ttname"><a href="group__image__drawing.html#gaf6b7b3f250d1fd2d961d55686528a276">oslDrawImage</a></div><div class="ttdeci">void oslDrawImage(OSL_IMAGE *img)</div><div class="ttdoc">Draws an image at its current position.</div></div>
<div class="ttc" id="agroup__image__pixel_html_ga1e009683f250dbeeeb7d8cb304b58ddd"><div class="ttname"><a href="#ga1e009683f250dbeeeb7d8cb304b58ddd">oslLockImage</a></div><div class="ttdeci">void oslLockImage(OSL_IMAGE *img)</div></div>
<div class="ttc" id="agroup__image__pixel_html_ga483de8582f4bdf0ec946e16f0cbd8856"><div class="ttname"><a href="#ga483de8582f4bdf0ec946e16f0cbd8856">oslUnlockImage</a></div><div class="ttdeci">void oslUnlockImage(OSL_IMAGE *img)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ga483de8582f4bdf0ec946e16f0cbd8856" name="ga483de8582f4bdf0ec946e16f0cbd8856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga483de8582f4bdf0ec946e16f0cbd8856">&#9670;&#160;</a></span>oslUnlockImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void oslUnlockImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_o_s_l___i_m_a_g_e.html">OSL_IMAGE</a> *</td>          <td class="paramname"><span class="paramname"><em>img</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlocks an image after modifications have been completed. This function should be called after using <code>oslLockImage</code> to release the lock and finalize any pending operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>Pointer to the <a class="el" href="struct_o_s_l___i_m_a_g_e.html" title="Structure representing an image loaded in memory.">OSL_IMAGE</a> structure representing the image to unlock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always ensure that <code>oslUnlockImage</code> is called after <code>oslLockImage</code> to properly finalize modifications and ensure the image is ready for rendering or further operations. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gae84026314c01744128932407470bc75b" name="gae84026314c01744128932407470bc75b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae84026314c01744128932407470bc75b">&#9670;&#160;</a></span>osl_pixelWidth</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int osl_pixelWidth[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of pixel widths (in bits) for each pixel format.</p>
<p>This array provides the number of bits used for each pixel in various pixel formats. The index of the array corresponds to the pixel format identifier.</p>
<dl class="section note"><dt>Note</dt><dd>For example, if <code>osl_pixelWidth[OSL_PF_8888]</code> is 32, it indicates that the <code>OSL_PF_8888</code> pixel format uses 32 bits per pixel. </dd></dl>

</div>
</div>
<a id="ga99e1b4c623f2ee9591b1b5ee098decb9" name="ga99e1b4c623f2ee9591b1b5ee098decb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99e1b4c623f2ee9591b1b5ee098decb9">&#9670;&#160;</a></span>osl_paletteSizes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const u8 osl_paletteSizes[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List of palette sizes (in powers of two) for each pixel format.</p>
<p>This array provides the size of the palette for each pixel format that uses palette-based color representation. For non-paletted formats, the value is zero. For paletted formats, the size of the palette can be calculated as <code>1 &lt;&lt; osl_paletteSizes[pixelFormat]</code>, where <code>pixelFormat</code> is the index into the array.</p>
<dl class="section note"><dt>Note</dt><dd>For example, if <code>osl_paletteSizes[OSL_PF_4BIT]</code> is 4, it indicates that the <code>OSL_PF_4BIT</code> pixel format uses a palette size of <code>1 &lt;&lt; 4</code>, or 16 colors. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
